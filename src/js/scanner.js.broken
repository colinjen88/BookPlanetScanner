/**
 * å¸ƒå¯æ˜Ÿçƒæ¢ç¢¼æƒæå™¨ - æ ¸å¿ƒæƒææ¨¡çµ„
 * è² è²¬æ¢ç¢¼æª¢æ¸¬ã€å½±åƒè™•ç†ã€æ”å½±æ©Ÿæ§åˆ¶ç­‰æ ¸å¿ƒåŠŸèƒ½
 */

// === æƒæå™¨æ ¸å¿ƒé¡åˆ¥ ===
class BarcodeScanner {
    constructor() {
        this.state = {
            running: false,
            detectionBusy: false,
            lastDetectionAt: 0,
            bookList: [],
            stream: null,
            track: null,
            flashOn: false,
            detectors: {
                barcodeDetector: null,
                multiFormatReader: null
            },
            stats: {
                frames: 0,
                valid: 0,
              }
    }

    // === æª¢æ¸¬æ–¹æ³• ===      success: 0
            },
            roi: {
                enabled: true,
                widthRatio: 0.78,
                heightRatio: 0.42
            },
            processing: {
                contrast: 1.35,
                brightness: 1.05,
                gamma: 0.9,
                denoise: true,
                sharpen: true
            },
            detection: {
                allowRotation: true,
                allowSlices: true,
                useBarcodeDetector: true,
                useZxing: true,
                intervalMs: 120,
                rotationAngles: [-12, -6, 6, 12],
                slices: [
                    { label: 'ä¸­å¿ƒ', topRatio: 0.25, heightRatio: 0.5 },
                    { label: 'ä¸Šæ–¹', topRatio: 0.05, heightRatio: 0.45 },
                    { label: 'ä¸‹æ–¹', topRatio: 0.5, heightRatio: 0.45 }
                ]
            },
            lastCodes: [],
            logSize: 120
        };

        this.SUPPORTED_FORMATS = [
            'ean_13', 'ean_8', 'upc_a', 'upc_e',
            'code_128', 'code_39', 'code_93', 'itf', 'codabar'
        ];

        this.ZXING_AVAILABLE = false;
        this.ZXING_FORMATS = [];

        this.elements = {};
        this.processingCanvas = null;
        this.processingCtx = null;
        this.scratchCanvas = null;
        this.scratchCtx = null;
    }

    // === åˆå§‹åŒ–æ–¹æ³• ===
    init(elements) {
        this.elements = elements;
        this.processingCanvas = document.getElementById('processingCanvas');
        this.processingCtx = this.processingCanvas.getContext('2d', { willReadFrequently: true });
        this.scratchCanvas = document.getElementById('scratchCanvas');
        this.scratchCtx = this.scratchCanvas.getContext('2d', { willReadFrequently: true });

        this.checkZXingAvailability();
        this.initDetectors();
        this.bindEvents();
        
        // é–‹ç™¼æ¨¡å¼ä¸‹æš´éœ²ç‹€æ…‹åˆ°å…¨åŸŸ
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            window.scanner = this;
            window.state = this.state;
        }

        return this.loadBookList();
    }

    // === ZXing å¯ç”¨æ€§æª¢æŸ¥ ===
    checkZXingAvailability() {
        try {
            if (typeof ZXing !== 'undefined' && ZXing.BrowserMultiFormatReader) {
                this.ZXING_AVAILABLE = true;
                this.ZXING_FORMATS = [
                    ZXing.BarcodeFormat.EAN_13,
                    ZXing.BarcodeFormat.EAN_8,
                    ZXing.BarcodeFormat.UPC_A,
                    ZXing.BarcodeFormat.UPC_E,
                    ZXing.BarcodeFormat.CODE_128,
                    ZXing.BarcodeFormat.CODE_39,
                    ZXing.BarcodeFormat.CODE_93,
                    ZXing.BarcodeFormat.ITF,
                    ZXing.BarcodeFormat.CODABAR
                ];
                this.log('âœ… ZXing åº«å·²è¼‰å…¥');
            } else {
                this.ZXING_AVAILABLE = false;
                this.log('âš ï¸ ZXing åº«æœªæ‰¾åˆ°ï¼Œå°‡åƒ…ä½¿ç”¨ BarcodeDetector');
            }
        } catch (error) {
            this.ZXING_AVAILABLE = false;
            this.log(`ZXing æª¢æŸ¥å¤±æ•—ï¼š${error.message}`);
        }
    }

    // === æ—¥èªŒåŠŸèƒ½ ===
    log(message) {
        const timestamp = new Date().toLocaleTimeString();
        console.log(`[${timestamp}] ${message}`);
    }

    // === è¼‰å…¥æ›¸ç±æ¸…å–® ===
    async loadBookList() {
        try {
            const response = await fetch('books_list.json?v=' + Date.now());
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            this.state.bookList = await response.json();
            this.log(`ğŸ“š è¼‰å…¥ ${this.state.bookList.length} æœ¬å¸ƒå¯æ˜Ÿçƒé¸æ›¸`);
        } catch (error) {
            this.log(`æ›¸å–®è¼‰å…¥å¤±æ•—ï¼š${error.message}`);
            this.state.bookList = [];
        }
    }

    // === åˆå§‹åŒ–æª¢æ¸¬å™¨ ===
    initDetectors() {
        // åˆå§‹åŒ– BarcodeDetector
        try {
            if ('BarcodeDetector' in window) {
                this.state.detectors.barcodeDetector = new BarcodeDetector({
                    formats: this.SUPPORTED_FORMATS
                });
                this.log('âœ… BarcodeDetector å·²åˆå§‹åŒ–');
            } else {
                this.log('âš ï¸ æ­¤ç€è¦½å™¨ä¸æ”¯æ´ BarcodeDetector');
            }
        } catch (error) {
            this.log(`âš ï¸ BarcodeDetector åˆå§‹åŒ–å¤±æ•—ï¼š${error.message}`);
        }

        // åˆå§‹åŒ– ZXing
        if (this.ZXING_AVAILABLE) {
            try {
                this.state.detectors.multiFormatReader = new ZXing.BrowserMultiFormatReader();
                const hints = new Map();
                hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, this.ZXING_FORMATS);
                hints.set(ZXing.DecodeHintType.TRY_HARDER, true);
                this.state.detectors.multiFormatReader.setHints(hints);
                this.log('âœ… ZXing MultiFormatReader å·²åˆå§‹åŒ–');
            } catch (error) {
                this.log(`âš ï¸ ZXing åˆå§‹åŒ–å¤±æ•—ï¼š${error.message}`);
                this.state.detectors.multiFormatReader = null;
            }
        }

        // è¨­å®šå®šæ™‚å™¨ï¼Œ1ç§’å¾Œåˆå§‹åŒ– ROI
        setTimeout(() => {
            this.updateRoiOverlay();
        }, 1000);
    }

    // === ROI è¦†è“‹å±¤æ›´æ–° ===
    updateRoiOverlay() {
        if (!this.elements.preview || !this.elements.roiOverlay) return;

        const video = this.elements.preview;
        const overlay = this.elements.roiOverlay;
        const container = video.parentElement;

        const videoRect = video.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();

        const roiWidth = videoRect.width * this.state.roi.widthRatio;
        const roiHeight = videoRect.height * this.state.roi.heightRatio;
        const roiLeft = (videoRect.width - roiWidth) / 2;
        const roiTop = (videoRect.height - roiHeight) / 2;

        overlay.style.left = roiLeft + 'px';
        overlay.style.top = roiTop + 'px';
        overlay.style.width = roiWidth + 'px';
        overlay.style.height = roiHeight + 'px';
        overlay.style.display = this.state.roi.enabled ? 'block' : 'none';
    }

    // === çµ±è¨ˆç›¸é—œæ–¹æ³• ===
    resetStats() {
        this.state.stats = { frames: 0, valid: 0, success: 0 };
        this.updateStatsDisplay();
    }

    updateStatsDisplay() {
        // çµ±è¨ˆæ›´æ–°é‚è¼¯æœƒç”± DataManager è™•ç†
        if (window.dataManager) {
            window.dataManager.updateStats(this.state.stats);
        }
    }

    pushRecentCode(code) {
        this.state.lastCodes.push(code);
        if (this.state.lastCodes.length > 5) this.state.lastCodes.shift();
    }

    wasRecentlySeen(code) {
        return this.state.lastCodes.includes(code);
    }

    // === å½±åƒè™•ç†æ–¹æ³• ===
    applyImageProcessing(imageData, width, height) {
        const data = imageData.data;
        const { contrast, brightness, gamma } = this.state.processing;

        for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];

            // å°æ¯”åº¦å’Œäº®åº¦èª¿æ•´
            r = this.clamp((r - 128) * contrast + 128 + brightness);
            g = this.clamp((g - 128) * contrast + 128 + brightness);
            b = this.clamp((b - 128) * contrast + 128 + brightness);

            // Gamma æ ¡æ­£
            if (gamma !== 1.0) {
                r = this.clamp(255 * Math.pow(r / 255, gamma));
                g = this.clamp(255 * Math.pow(g / 255, gamma));
                b = this.clamp(255 * Math.pow(b / 255, gamma));
            }

            data[i] = r;
            data[i + 1] = g;
            data[i + 2] = b;
        }

        if (this.state.processing.denoise) {
            this.applyBoxBlur(imageData, width, height);
        }

        if (this.state.processing.sharpen) {
            this.applyUnsharpMask(imageData, width, height);
        }

        return imageData;
    }

    clamp(value, min = 0, max = 255) {
        return Math.min(Math.max(value, min), max);
    }

    applyBoxBlur(imageData, width, height) {
        const data = imageData.data;
        const radius = 1;
        const output = new Uint8ClampedArray(data);

        for (let y = radius; y < height - radius; y++) {
            for (let x = radius; x < width - radius; x++) {
                let r = 0, g = 0, b = 0, count = 0;

                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const idx = ((y + dy) * width + (x + dx)) * 4;
                        r += data[idx];
                        g += data[idx + 1];
                        b += data[idx + 2];
                        count++;
                    }
                }

                const idx = (y * width + x) * 4;
                output[idx] = r / count;
                output[idx + 1] = g / count;
                output[idx + 2] = b / count;
            }
        }

        data.set(output);
    }

    applyUnsharpMask(imageData, width, height) {
        const data = imageData.data;
        const original = new Uint8ClampedArray(data);
        const strength = 1.5;
        const threshold = 0;

        // å…ˆæ‡‰ç”¨é«˜æ–¯æ¨¡ç³Š
        this.applyBoxBlur(imageData, width, height);

        // è¨ˆç®—éŠ³åŒ–
        for (let i = 0; i < data.length; i += 4) {
            const diff_r = original[i] - data[i];
            const diff_g = original[i + 1] - data[i + 1];
            const diff_b = original[i + 2] - data[i + 2];

            if (Math.abs(diff_r) > threshold) {
                data[i] = this.clamp(original[i] + diff_r * strength);
            } else {
                data[i] = original[i];
            }

            if (Math.abs(diff_g) > threshold) {
                data[i + 1] = this.clamp(original[i + 1] + diff_g * strength);
            } else {
                data[i + 1] = original[i + 1];
            }

            if (Math.abs(diff_b) > threshold) {
                data[i + 2] = this.clamp(original[i + 2] + diff_b * strength);
            } else {
                data[i + 2] = original[i + 2];
            }
        }
    }

    // === ROI è¨ˆç®— ===
    computeRoi(videoWidth, videoHeight) {
        if (!this.state.roi.enabled) {
            return {
                x: 0, y: 0,
                width: videoWidth,
                height: videoHeight
            };
        }

        const roiWidth = Math.floor(videoWidth * this.state.roi.widthRatio);
        const roiHeight = Math.floor(videoHeight * this.state.roi.heightRatio);
        const roiX = Math.floor((videoWidth - roiWidth) / 2);
        const roiY = Math.floor((videoHeight - roiHeight) / 2);

        return {
            x: roiX, y: roiY,
            width: roiWidth, height: roiHeight
        };
    }

    // === æ¢ç¢¼è™•ç†æ–¹æ³• ===
    advancedBarcodeProcessor(rawCode) {
        if (!rawCode || typeof rawCode !== 'string') return null;

        let cleaned = rawCode.trim().replace(/[^\d]/g, '');

        // EAN-13 è™•ç†
        if (cleaned.length >= 12 && cleaned.length <= 14) {
            if (cleaned.length === 12) {
                cleaned = this.calculateEAN13CheckDigit(cleaned);
            } else if (cleaned.length === 14 && cleaned.startsWith('0')) {
                cleaned = cleaned.substring(1);
            }

            if (cleaned.length === 13 && this.validateEAN13(cleaned)) {
                return cleaned;
            }
        }

        // ISBN-10 è½‰ EAN-13
        if (cleaned.length === 10 && cleaned.match(/^\d{9}[\dX]$/)) {
            return '978' + cleaned.substring(0, 9) + this.calculateEAN13CheckDigit('978' + cleaned.substring(0, 9));
        }

        // å…¶ä»–é•·åº¦çš„æ•¸å­—ç¢¼
        if (cleaned.length >= 8 && cleaned.length <= 14) {
            return cleaned;
        }

        return null;
    }

    calculateEAN13CheckDigit(code12) {
        let sum = 0;
        for (let i = 0; i < 12; i++) {
            const digit = parseInt(code12[i]);
            sum += (i % 2 === 0) ? digit : digit * 3;
        }
        const checkDigit = (10 - (sum % 10)) % 10;
        return code12 + checkDigit;
    }

    validateEAN13(code) {
        if (code.length !== 13 || !/^\d+$/.test(code)) return false;
        let sum = 0;
        for (let i = 0; i < 12; i++) {
            const digit = parseInt(code[i]);
            sum += (i % 2 === 0) ? digit : digit * 3;
        }
        const checkDigit = (10 - (sum % 10)) % 10;
        return checkDigit === parseInt(code[12]);
    }

    // === æ™ºæ…§æ›¸ç±åŒ¹é… ===
    intelligentBookMatch(rawCode) {
        const processedCode = this.advancedBarcodeProcessor(rawCode);
        if (!processedCode) return { found: null, matchedCode: null, original: rawCode };

        const exactMatch = this.state.bookList.find(book => book.ISBN === processedCode);
        if (exactMatch) {
            return { found: exactMatch, matchedCode: processedCode, original: rawCode };
        }

        // å‰ç¶´åŒ¹é…ï¼ˆé‡å°ä¸åŒç‰ˆæœ¬ï¼‰
        if (processedCode.length >= 10) {
            const prefix = processedCode.substring(0, 10);
            const prefixMatch = this.state.bookList.find(book => 
                book.ISBN && book.ISBN.substring(0, 10) === prefix
            );
            if (prefixMatch) {
                return { found: prefixMatch, matchedCode: prefixMatch.ISBN, original: rawCode };
            }
        }

        return { found: null, matchedCode: processedCode, original: rawCode };
    }

    // === æª¢æ¸¬æ–¹æ³• ===
    async detectWithBarcodeDetector(canvas) {
        if (!this.state.detectors.barcodeDetector) return [];
        
        try {
            const barcodes = await this.state.detectors.barcodeDetector.detect(canvas);
            return barcodes.map(barcode => ({
                text: barcode.rawValue,
                format: barcode.format,
                source: 'BarcodeDetector'
            }));
        } catch (error) {
            this.log(`BarcodeDetector å¤±æ•—ï¼š${error.message}`);
            return [];
        }
    }

    detectWithZxing(canvas) {
        if (!this.state.detectors.multiFormatReader) return [];

        try {
            const result = this.state.detectors.multiFormatReader.decodeFromCanvas(canvas);
            return [{
                text: result.getText(),
                format: result.getBarcodeFormat(),
                source: 'ZXing'
            }];
        } catch (error) {
            // é‡ç½® ZXing å¯¦ä¾‹ä»¥é˜²ç‹€æ…‹éŒ¯èª¤
            if (error.message && error.message.includes('state')) {
                try {
                    this.state.detectors.multiFormatReader.reset();
                } catch (resetError) {
                    this.log(`ZXing reset å¤±æ•—ï¼š${resetError.message}`);
                }
            }
            // ZXing æ‰¾ä¸åˆ°æ¢ç¢¼æ™‚æœƒæ‹‹å‡º NotFoundExceptionï¼Œé€™æ˜¯æ­£å¸¸çš„
            if (!error.message || !error.message.includes('NotFoundException')) {
                this.log(`ZXing å¤±æ•—ï¼š${error.message}`);
            }
            return [];
        }
    }

    async detectFromCanvas(canvas, stageLabel) {
        const results = [];

        if (this.state.detection.useBarcodeDetector) {
            const barcodeResults = await this.detectWithBarcodeDetector(canvas);
            results.push(...barcodeResults);
        }

        if (this.state.detection.useZxing) {
            const zxingResults = this.detectWithZxing(canvas);
            results.push(...zxingResults);
        }

        return results.length > 0 ? { stage: stageLabel, results } : null;
    }

    // === ä¸»è¦æª¢æ¸¬é‚è¼¯ ===
    async tryDetections() {
        const video = this.elements.preview;
        if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) return null;

        const videoWidth = video.videoWidth;
        const videoHeight = video.videoHeight;

        if (!videoWidth || !videoHeight) return null;

        const roi = this.computeRoi(videoWidth, videoHeight);

        // è¨­ç½®è™•ç†ç•«å¸ƒ
        this.processingCanvas.width = roi.width;
        this.processingCanvas.height = roi.height;
        this.scratchCanvas.width = roi.width;
        this.scratchCanvas.height = roi.height;

        // ç¹ªè£½ ROI å€åŸŸåˆ°ç•«å¸ƒ
        this.processingCtx.drawImage(video, roi.x, roi.y, roi.width, roi.height, 0, 0, roi.width, roi.height);

        // å½±åƒè™•ç†
        const imageData = this.processingCtx.getImageData(0, 0, roi.width, roi.height);
        const processedImageData = this.applyImageProcessing(imageData, roi.width, roi.height);
        this.processingCtx.putImageData(processedImageData, 0, 0);

        // å˜—è©¦ç›´æ¥æª¢æ¸¬
        const directResult = await this.detectFromCanvas(this.processingCanvas, 'ç›´æ¥æª¢æ¸¬');
        if (directResult) return directResult;

        // å˜—è©¦æ—‹è½‰æª¢æ¸¬
        if (this.state.detection.allowRotation) {
            for (const angle of this.state.detection.rotationAngles) {
                this.scratchCtx.clearRect(0, 0, roi.width, roi.height);
                this.scratchCtx.save();
                this.scratchCtx.translate(roi.width / 2, roi.height / 2);
                this.scratchCtx.rotate((angle * Math.PI) / 180);
                this.scratchCtx.drawImage(this.processingCanvas, -roi.width / 2, -roi.height / 2);
                this.scratchCtx.restore();

                const rotationResult = await this.detectFromCanvas(this.scratchCanvas, `æ—‹è½‰${angle}Â°`);
                if (rotationResult) return rotationResult;
            }
        }

        // å˜—è©¦åˆ‡ç‰‡æª¢æ¸¬
        if (this.state.detection.allowSlices) {
            for (const slice of this.state.detection.slices) {
                const sliceY = Math.floor(roi.height * slice.topRatio);
                const sliceHeight = Math.floor(roi.height * slice.heightRatio);

                this.scratchCanvas.width = roi.width;
                this.scratchCanvas.height = sliceHeight;
                this.scratchCtx.drawImage(this.processingCanvas, 0, sliceY, roi.width, sliceHeight, 0, 0, roi.width, sliceHeight);

                const sliceResult = await this.detectFromCanvas(this.scratchCanvas, `åˆ‡ç‰‡-${slice.label}`);
                if (sliceResult) return sliceResult;
            }
        }

        return null;
    }

    // === æƒæä¸»å¾ªç’° ===
    async scanLoop() {
        while (this.state.running) {
            await new Promise(resolve => requestAnimationFrame(resolve));
            if (!this.state.running) break;
            if (this.state.detectionBusy) continue;
            
            this.state.detectionBusy = true;
            try {
                const detection = await this.processFrame();
                if (detection) {
                    this.handleDetection(detection);
                }
            } catch (error) {
                this.log(`æƒæè¿´åœˆéŒ¯èª¤ï¼š${error.message}`);
            } finally {
                this.state.detectionBusy = false;
            }
        }
    }

    // === æª¢æ¸¬çµæœè™•ç† ===
    handleDetection(detection) {
        this.state.stats.frames++;

        for (const result of detection.results) {
            if (this.wasRecentlySeen(result.text)) continue;

            this.pushRecentCode(result.text);
            const match = this.intelligentBookMatch(result.text);

            if (match.matchedCode) {
                this.state.stats.valid++;
                this.log(`âœ… [${detection.stage}] æœ‰æ•ˆæ¢ç¢¼ï¼š${match.matchedCode} (åŸå§‹: ${match.original})`);

                // å…ˆé¡¯ç¤º Loading ç•«é¢
                if (window.uiUtils) {
                    window.uiUtils.showLoadingCard();
                }

                // 0.7ç§’å¾Œé¡¯ç¤ºå¯¦éš›çµæœ
                setTimeout(() => {
                    if (window.uiUtils) {
                        window.uiUtils.updateResultCardForMatch(match);
                    }

                    if (!match.found) {
                        setTimeout(() => {
                            this.updateEngineBadge('æŒçºŒæƒæä¸­â€¦');
                        }, 2000);
                        return;
                    }

                    this.log('ğŸ¯ æ‰¾åˆ°åŒ¹é…æ›¸ç±ï¼Œæº–å‚™é¡¯ç¤º popover');

                    // é¡¯ç¤ºæˆåŠŸpopover
                    if (window.uiUtils) {
                        window.uiUtils.showSuccessPopover();
                    }
                    this.stop(false);
                }, 700);
            }
        }

        this.updateStatsDisplay();
    }

    // === å¼•æ“ç‹€æ…‹æ›´æ–° ===
    updateEngineBadge(text, success = false) {
        if (!this.elements.engineBadge) return;
        this.elements.engineBadge.textContent = text;
        this.elements.engineBadge.className = success ? 'hud-badge success' : 'hud-badge';
    }

    // === æ”å½±æ©Ÿæ§åˆ¶ ===
    async start() {
        if (this.state.running) return;

        try {
            this.resetStats();
            this.updateEngineBadge('å•Ÿå‹•æ”å½±æ©Ÿâ€¦');
            this.elements.engineStatus.textContent = 'å•Ÿå‹•ä¸­';
            this.log('æ­£åœ¨åˆå§‹åŒ–æ”å½±æ©Ÿâ€¦');

            // å˜—è©¦ä½¿ç”¨ç°¡åŒ–çš„æ”å½±æ©Ÿè¨­å®š
            try {
                this.state.stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
            } catch (error) {
                // å¦‚æœå¤±æ•—ï¼Œå˜—è©¦åŸºæœ¬è¨­å®š
                this.log('å˜—è©¦åŸºæœ¬æ”å½±æ©Ÿè¨­å®š...');
                this.state.stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
            }

            this.elements.preview.srcObject = this.state.stream;
            this.state.track = this.state.stream.getVideoTracks()[0];

            this.elements.preview.onloadedmetadata = () => {
                this.elements.preview.play();
                this.state.running = true;

                this.elements.startBtn.style.display = 'none';
                this.elements.stopBtn.style.display = 'inline-flex';
                this.elements.flashOffBtn.disabled = false;
                this.elements.flashOnBtn.disabled = false;

                this.log('âœ… æ”å½±æ©Ÿå·²å•Ÿå‹•ï¼Œé–‹å§‹æƒæ');
                this.updateEngineBadge('æƒæä¸­...', true);
                this.elements.engineStatus.textContent = 'ZXing + BarcodeDetector @ æ™ºæ…§æª¢æ¸¬';

                setTimeout(() => this.updateRoiOverlay(), 500);
                this.scanLoop();
            };

        } catch (error) {
            this.log(`âŒ ç„¡æ³•å•Ÿå‹•æ”å½±æ©Ÿï¼š${error.message}`);
            this.state.running = false;

            let errorMessage = 'æ”å½±æ©Ÿå•Ÿå‹•å¤±æ•—';
            if (error.name === 'NotAllowedError') {
                errorMessage = 'âŒ æ”å½±æ©Ÿæ¬Šé™è¢«æ‹’çµ•ï¼Œè«‹å…è¨±æ­¤ç¶²ç«™ä½¿ç”¨æ”å½±æ©Ÿã€‚';
            } else if (error.name === 'NotFoundError') {
                errorMessage = 'âŒ æ‰¾ä¸åˆ°æ”å½±æ©Ÿè¨­å‚™ï¼Œè«‹ç¢ºèªæ”å½±æ©Ÿå·²é€£æ¥ã€‚';
            } else if (error.name === 'NotReadableError') {
                errorMessage = 'âŒ æ”å½±æ©Ÿæ­£è¢«å…¶ä»–æ‡‰ç”¨ç¨‹å¼ä½¿ç”¨ä¸­ã€‚';
            } else {
                errorMessage = `âŒ æ”å½±æ©Ÿå•Ÿå‹•å¤±æ•—ï¼š${error.message}`;
            }

            if (this.elements.resultCard) {
                this.elements.resultCard.textContent = errorMessage;
            }
        }
    }

    stop(resetStatsToo = true) {
        if (this.state.stream) {
            try { this.state.stream.getTracks().forEach(track => track.stop()); } catch (error) { this.log(`åœæ­¢ stream å¤±æ•—ï¼š${error.message}`); }
            try { this.state.track.stop(); } catch (error) { this.log(`åœæ­¢ track å¤±æ•—ï¼š${error.message}`); }
        }

        this.state.running = false;
        this.state.detectionBusy = false;
        this.state.stream = null;
        this.state.track = null;
        this.state.flashOn = false;

        if (resetStatsToo) this.resetStats();

        this.elements.startBtn.style.display = 'inline-flex';
        this.elements.stopBtn.style.display = 'none';
        
        // é‡ç½®æ‰‹é›»ç­’æŒ‰éˆ•ç‹€æ…‹
        this.elements.flashOffBtn.disabled = true;
        this.elements.flashOnBtn.disabled = true;
        this.elements.flashOffBtn.style.display = 'block';
        this.elements.flashOnBtn.style.display = 'none';
        
        this.elements.roiOverlay.style.display = 'none';

        this.updateEngineBadge('å¾…å‘½ä¸­...');
        this.elements.engineStatus.textContent = 'å·²åœæ­¢';
        this.log('æƒæå·²åœæ­¢');
    }

    // === æ‰‹é›»ç­’æ§åˆ¶ ===
    toggleFlash() {
        if (!this.state.track) return;
        
        // ç«‹å³åˆ‡æ›è¦–è¦ºç‹€æ…‹ï¼Œä¸ç­‰å¾… API
        this.state.flashOn = !this.state.flashOn;
        
        // ç«‹å³åˆ‡æ›æŒ‰éˆ•é¡¯ç¤ºï¼ˆCSS æ§åˆ¶ï¼Œå®Œå…¨å³æ™‚ï¼‰
        this.updateFlashButtonUI();
        
        // ç•°æ­¥è™•ç†å¯¦éš›çš„ç¡¬é«”æ§åˆ¶ï¼Œä¸é˜»å¡ UI
        this.applyFlashConstraints();
    }

    updateFlashButtonUI() {
        // ä½¿ç”¨ CSS display æ§åˆ¶ - å®Œå…¨ç„¡å»¶é²
        const flashOffBtn = this.elements.flashOffBtn;
        const flashOnBtn = this.elements.flashOnBtn;
        
        if (this.state.flashOn) {
            // é¡¯ç¤ºæ©˜è‰²çš„ã€Œé—œé–‰æ‰‹é›»ç­’ã€æŒ‰éˆ•
            flashOffBtn.style.display = 'none';
            flashOnBtn.style.display = 'block';
        } else {
            // é¡¯ç¤ºè—è‰²çš„ã€Œæ‰‹é›»ç­’ã€æŒ‰éˆ•
            flashOffBtn.style.display = 'block';
            flashOnBtn.style.display = 'none';
        }
        
        this.log(`æ‰‹é›»ç­’å·²${this.state.flashOn ? 'é–‹å•Ÿ' : 'é—œé–‰'}`);
    }

    async applyFlashConstraints() {
        try {
            const capabilities = this.state.track.getCapabilities();
            if (!capabilities.torch) {
                this.log('æ­¤è¨­å‚™ä¸æ”¯æ´æ‰‹é›»ç­’');
                // å¦‚æœä¸æ”¯æ´ï¼Œå›æ»¾ç‹€æ…‹
                this.state.flashOn = !this.state.flashOn;
                this.updateFlashButtonUI();
                return;
            }

            // éé˜»å¡çš„ API èª¿ç”¨
            await this.state.track.applyConstraints({
                advanced: [{ torch: this.state.flashOn }]
            });
            
        } catch (error) {
            this.log(`æ‰‹é›»ç­’åˆ‡æ›å¤±æ•—ï¼š${error.message}`);
            // API å¤±æ•—æ™‚å›æ»¾ UI ç‹€æ…‹
            this.state.flashOn = !this.state.flashOn;
            this.updateFlashButtonUI();
        }
    }

    async applyFlashConstraints() {
        try {
            const capabilities = this.state.track.getCapabilities();
            if (!capabilities.torch) {
                this.log('æ­¤è¨­å‚™ä¸æ”¯æ´æ‰‹é›»ç­’');
                // å¦‚æœä¸æ”¯æ´ï¼Œå›æ»¾ç‹€æ…‹
                this.state.flashOn = !this.state.flashOn;
                this.updateFlashButtonUI();
                return;
            }

            // éé˜»å¡çš„ API èª¿ç”¨
            await this.state.track.applyConstraints({
                advanced: [{ torch: this.state.flashOn }]
            });
            
        } catch (error) {
            this.log(`æ‰‹é›»ç­’åˆ‡æ›å¤±æ•—ï¼š${error.message}`);
            // API å¤±æ•—æ™‚å›æ»¾ UI ç‹€æ…‹
            this.state.flashOn = !this.state.flashOn;
            this.updateFlashButtonUI();
        }
    }

    // === äº‹ä»¶ç¶å®š ===
    bindEvents() {
        this.elements.startBtn.addEventListener('click', () => this.start());
        this.elements.stopBtn.addEventListener('click', () => this.stop(false));
        
        // å…©å€‹æ‰‹é›»ç­’æŒ‰éˆ•éƒ½ä½¿ç”¨ click äº‹ä»¶ï¼ˆå› ç‚ºåˆ‡æ›æ˜¯å³æ™‚çš„ï¼‰
        this.elements.flashOffBtn.addEventListener('click', () => this.toggleFlash());
        this.elements.flashOnBtn.addEventListener('click', () => this.toggleFlash());

        window.addEventListener('resize', () => this.updateRoiOverlay());
    }
}

// === å…¨åŸŸæš´éœ² ===
window.BarcodeScanner = BarcodeScanner;