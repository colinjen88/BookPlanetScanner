<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <!-- Google Tag Manager -->
    <script>
        (function (w, d, s, l, i) {
            w[l] = w[l] || [];
            w[l].push({
                'gtm.start': new Date().getTime(),
                event: 'gtm.js'
            });
            var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s),
                dl = l != 'dataLayer' ? '&l=' + l : '';
            j.async = true;
            j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-N2CMV5HF');
    </script>
    <!-- End Google Tag Manager -->
    <meta charset="UTF-8">
    <title>å¸ƒå¯æ˜Ÿçƒæ¢ç¢¼æƒæå™¨</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://unpkg.com/@zxing/library@latest"></script>
    <script src="https://unpkg.com/@zxing/browser@latest"></script>
    <link rel="stylesheet" href="scan.css">
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript>
        <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-N2CMV5HF" height="0" width="0"
            style="display:none;visibility:hidden">
        </iframe>
    </noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div class="container">
        <div class="header-row">
            <h1>ğŸ“˜<span>å¸ƒå¯æ˜ŸçƒæŸ¥è©¢</span></h1>
            <button class="header-flash-btn" id="flashBtnHeader" disabled>
                <span id="flashIconHeader">ğŸ”¦æ‰‹é›»ç­’</span>
            </button>
        </div>
        <p class="subtitle">æƒææ›¸æœ¬æ¢ç¢¼ï¼Œåˆ¤åˆ¥æ˜¯å¦ç‚ºå¸ƒå¯æ˜Ÿçƒé¸æ›¸ã€‚</p>

        <div class="button-row">
            <button class="btn btn-main" id="startBtn">ğŸš€ é–‹å§‹æƒææ¢ç¢¼</button>
            <button class="btn btn-main danger" id="stopBtn" disabled style="display: none;">â¹ï¸ åœæ­¢</button>
        </div>

        <div class="video-shell" id="videoShell">
            <video id="preview" autoplay playsinline muted></video>
            <div class="roi-overlay" id="roiOverlay"></div>
            <span class="hud-badge" id="engineBadge">å¾…å‘½ä¸­â€¦</span>
        </div>

        <div class="result-card" id="resultCard">
            âœ… è¼‰å…¥å¾Œè«‹é»ã€Œé–‹å§‹æƒæã€ï¼Œå°‡æ›¸æœ¬æ¢ç¢¼ç½®ä¸­ä¸¦ç¶­æŒ 15-20 å…¬åˆ†è·é›¢ã€‚
        </div>

        <div class="status-board" id="statusBoard">
            <div>ğŸ“· ç›¸æ©Ÿç‹€æ…‹ï¼š<span id="cameraStatus">å°šæœªå•Ÿå‹•</span></div>
            <div>ğŸ§  å¼•æ“ç‹€æ…‹ï¼š<span id="engineStatus">å°šæœªæƒæ</span></div>
        </div>

        <div class="success-popover" id="successPopover" style="display: none;">
            âœ… æƒææˆåŠŸï¼
        </div>

        <!-- æ¸¬è©¦æŒ‰éˆ• (é–‹ç™¼ç”¨ï¼Œå¯éš±è—) -->
        <button id="testSuccessBtn" style="position: fixed; 
                       bottom: 20px; 
                       right: 20px; 
                       z-index: 10000; 
                       background: #059669; 
                       color: white; 
                       border: none; 
                       padding: 10px 12px; 
                       border-radius: 8px; 
                       font-size: 12px;
                       font-weight: 500;
                       cursor: pointer;
                       box-shadow: 0 2px 8px rgba(0,0,0,0.2);">
            ğŸ“š æ¸¬è©¦å¸ƒå¯é¸æ›¸
        </button>

    </div>

    <canvas id="processingCanvas" class="hidden"></canvas>
    <canvas id="scratchCanvas" class="hidden"></canvas>

    <script>
        (() => {
            // === DOM å…ƒç´ å¿«å– ===
            const elements = {
                startBtn: document.getElementById('startBtn'),
                stopBtn: document.getElementById('stopBtn'),
                flashBtnHeader: document.getElementById('flashBtnHeader'),
                flashIconHeader: document.getElementById('flashIconHeader'),
                preview: document.getElementById('preview'),
                roiOverlay: document.getElementById('roiOverlay'),
                engineBadge: document.getElementById('engineBadge'),
                cameraStatus: document.getElementById('cameraStatus'),
                engineStatus: document.getElementById('engineStatus'),
                resultCard: document.getElementById('resultCard'),
                statusBoard: document.getElementById('statusBoard'),
                successPopover: document.getElementById('successPopover')
            };

            // === Canvas å…ƒç´ å’Œä¸Šä¸‹æ–‡ ===
            const processingCanvas = document.getElementById('processingCanvas');
            const processingCtx = processingCanvas.getContext('2d', { willReadFrequently: true });
            const scratchCanvas = document.getElementById('scratchCanvas');
            const scratchCtx = scratchCanvas.getContext('2d', { willReadFrequently: true });

            // === æ‡‰ç”¨ç¨‹å¼ç‹€æ…‹ ===
            const state = {
                // æƒæç‹€æ…‹
                running: false,
                detectionBusy: false,
                lastDetectionAt: 0,

                // è³‡æ–™ç‹€æ…‹
                bookList: [],
                stream: null,
                track: null,
                flashOn: false,

                // æª¢æ¸¬å¼•æ“
                detectors: {
                    barcodeDetector: null,
                    multiFormatReader: null
                },

                // çµ±è¨ˆè³‡æ–™
                stats: {
                    frames: 0,
                    valid: 0,
                    success: 0
                },

                // ROI è¨­å®š
                roi: {
                    enabled: true,
                    widthRatio: 0.78,
                    heightRatio: 0.42
                },

                // å½±åƒè™•ç†è¨­å®š
                processing: {
                    contrast: 1.35,
                    brightness: 1.05,
                    gamma: 0.9,
                    denoise: true,
                    sharpen: true
                },

                // æª¢æ¸¬è¨­å®š
                detection: {
                    allowRotation: true,
                    allowSlices: true,
                    useBarcodeDetector: true,
                    useZxing: true,
                    intervalMs: 120,
                    rotationAngles: [-12, -6, 6, 12],
                    slices: [
                        { label: 'ä¸­å¿ƒ', topRatio: 0.25, heightRatio: 0.5 },
                        { label: 'ä¸Šæ–¹', topRatio: 0.05, heightRatio: 0.45 },
                        { label: 'ä¸‹æ–¹', topRatio: 0.5, heightRatio: 0.45 }
                    ]
                },

                // å¿«å–å’Œæ—¥èªŒ
                lastCodes: [],
                logSize: 120
            };

            // === å¸¸æ•¸å®šç¾© ===
            const SUPPORTED_FORMATS = [
                'ean_13', 'ean_8', 'upc_a', 'upc_e',
                'code_128', 'code_39', 'code_93', 'itf', 'codabar'
            ];

            // ZXing ç›¸é—œè®Šæ•¸
            let ZXING_AVAILABLE = false;
            let ZXING_FORMATS = [];

            // === è¼”åŠ©å‡½æ•¸ ===

            /**
             * æª¢æŸ¥ ZXing æ˜¯å¦å¯ç”¨ï¼ˆå»¶é²æª¢æŸ¥ï¼‰
             * @returns {boolean} ZXing æ˜¯å¦å¯ç”¨
             */
            function checkZXingAvailability() {
                try {
                    ZXING_AVAILABLE = typeof window.ZXing !== 'undefined' &&
                        typeof window.ZXingBrowser !== 'undefined';

                    if (ZXING_AVAILABLE) {
                        ZXING_FORMATS = [
                            ZXing.BarcodeFormat.EAN_13,
                            ZXing.BarcodeFormat.EAN_8,
                            ZXing.BarcodeFormat.UPC_A,
                            ZXing.BarcodeFormat.UPC_E,
                            ZXing.BarcodeFormat.CODE_128,
                            ZXing.BarcodeFormat.CODE_39,
                            ZXing.BarcodeFormat.ITF
                        ];
                    }
                    return ZXING_AVAILABLE;
                } catch (error) {
                    log(`ZXing æª¢æŸ¥å¤±æ•—ï¼š${error.message}`);
                    ZXING_AVAILABLE = false;
                    return false;
                }
            }

            /**
             * é™åˆ¶æ•¸å€¼åœ¨æŒ‡å®šç¯„åœå…§
             * @param {number} value - è¦é™åˆ¶çš„å€¼
             * @param {number} min - æœ€å°å€¼
             * @param {number} max - æœ€å¤§å€¼
             * @returns {number} é™åˆ¶å¾Œçš„å€¼
             */
            function clamp(value, min = 0, max = 255) {
                return Math.min(max, Math.max(min, value));
            }

            /**
             * è¼¸å‡ºå¸¶æ™‚é–“æˆ³çš„æ—¥èªŒè¨Šæ¯
             * @param {string} message - æ—¥èªŒè¨Šæ¯
             */
            function log(message) {
                const timestamp = new Date().toLocaleTimeString('zh-TW', { hour12: false });
                console.log(`[${timestamp}] ${message}`);
            }

            /**
             * éåŒæ­¥è¼‰å…¥æ›¸ç±æ¸…å–®è³‡æ–™
             * @returns {Promise<void>}
             */
            async function loadBookList() {
                try {
                    const response = await fetch('books_list.json');
                    state.bookList = await response.json();

                    // æ›´æ–° UI é¡¯ç¤ºè¼‰å…¥çµæœ
                    elements.resultCard.classList.remove('error', 'success');
                    elements.resultCard.textContent = `ğŸ“š å·²è¼‰å…¥ ${state.bookList.length} æœ¬å¸ƒå¯æ˜Ÿçƒé¸æ›¸ï¼Œæº–å‚™é–‹å§‹æƒæã€‚`;

                    // å°‡ state æš´éœ²çµ¦å…¨åŸŸï¼Œä¾›çµ±è¨ˆåŠŸèƒ½ä½¿ç”¨
                    window.state = state;

                    // è§¸ç™¼è‡ªå®šç¾©äº‹ä»¶ï¼Œé€šçŸ¥æ›¸ç±è¼‰å…¥å®Œæˆ
                    window.dispatchEvent(new CustomEvent('booksLoaded', {
                        detail: { count: state.bookList.length }
                    }));
                } catch (error) {
                    elements.resultCard.classList.add('error');
                    elements.resultCard.textContent = 'âŒ æ›¸å–®è¼‰å…¥å¤±æ•—ï¼Œè«‹ç¢ºèª books_list.json æ˜¯å¦å­˜åœ¨ã€‚';
                    log(`æ›¸å–®è¼‰å…¥å¤±æ•—ï¼š${error.message}`);

                    // è¼‰å…¥å¤±æ•—æ™‚ä¹Ÿè§¸ç™¼äº‹ä»¶
                    window.dispatchEvent(new CustomEvent('booksLoadError'));
                }
            }

            function initDetectors() {
                // åˆå§‹åŒ– BarcodeDetector
                if ('BarcodeDetector' in window) {
                    try {
                        state.detectors.barcodeDetector = new BarcodeDetector({ formats: SUPPORTED_FORMATS });
                        log('âœ… BarcodeDetector å·²å•Ÿç”¨');
                    } catch (error) {
                        log(`âš ï¸ BarcodeDetector åˆå§‹åŒ–å¤±æ•—ï¼š${error.message}`);
                        state.detectors.barcodeDetector = null;
                        state.detection.useBarcodeDetector = false;
                    }
                } else {
                    log('â„¹ï¸ æ­¤è£ç½®å°šæœªæ”¯æ´ BarcodeDetector åŸç”Ÿ APIã€‚');
                    state.detectors.barcodeDetector = null;
                    state.detection.useBarcodeDetector = false;
                }

                // å»¶é²åˆå§‹åŒ– ZXing
                setTimeout(() => {
                    if (!checkZXingAvailability()) {
                        log('â„¹ï¸ ZXing Browser å¥—ä»¶æœªå®Œå…¨è¼‰å…¥ï¼Œå°‡ä¸»è¦ä¾è³´åŸç”Ÿå¼•æ“ã€‚');
                        state.detectors.multiFormatReader = null;
                        state.detection.useZxing = false;
                        return;
                    }

                    try {
                        const hints = new Map();
                        hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, ZXING_FORMATS);
                        hints.set(ZXing.DecodeHintType.TRY_HARDER, true);
                        const reader = new ZXing.MultiFormatReader();
                        reader.setHints(hints);
                        state.detectors.multiFormatReader = reader;
                        log('âœ… ZXing MultiFormatReader å·²å•Ÿç”¨');
                    } catch (error) {
                        log(`âš ï¸ ZXing åˆå§‹åŒ–å¤±æ•—ï¼š${error.message}`);
                        state.detectors.multiFormatReader = null;
                        state.detection.useZxing = false;
                    }
                }, 1000); // å»¶é²1ç§’åˆå§‹åŒ–ZXing
            }

            function updateRoiOverlay() {
                if (!state.roi.enabled) {
                    elements.roiOverlay.style.display = 'none';
                    return;
                }
                const video = elements.preview;
                if (!video.videoWidth || !video.videoHeight) {
                    elements.roiOverlay.style.display = 'none';
                    return;
                }
                const container = document.getElementById('videoShell');
                const rect = container.getBoundingClientRect();
                const roiWidth = rect.width * state.roi.widthRatio;
                const roiHeight = rect.height * state.roi.heightRatio;
                elements.roiOverlay.style.display = 'block';
                elements.roiOverlay.style.width = `${roiWidth}px`;
                elements.roiOverlay.style.height = `${roiHeight}px`;
                elements.roiOverlay.style.left = `${(rect.width - roiWidth) / 2}px`;
                elements.roiOverlay.style.top = `${(rect.height - roiHeight) / 2}px`;
            }

            function resetStats() {
                state.stats.frames = 0;
                state.stats.valid = 0;
                state.stats.success = 0;
                state.lastCodes = [];
                updateStatsDisplay();
            }

            function updateStatsDisplay() {
                // Stats tracking kept for internal logic but not displayed
            }

            function pushRecentCode(code) {
                state.lastCodes.push(code);
                if (state.lastCodes.length > 12) state.lastCodes.shift();
            }

            function wasRecentlySeen(code) {
                return state.lastCodes.includes(code);
            }

            function applyImageProcessing(imageData, width, height) {
                const data = imageData.data;
                const contrast = state.processing.contrast;
                const brightness = state.processing.brightness;
                const gamma = state.processing.gamma;

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    let gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    gray = gray * brightness;
                    gray = (gray - 128) * contrast + 128;
                    gray = 255 * Math.pow(clamp(gray) / 255, gamma);
                    const value = clamp(gray);
                    data[i] = data[i + 1] = data[i + 2] = value;
                }

                if (state.processing.denoise) {
                    applyBoxBlur(imageData, width, height);
                }

                if (state.processing.sharpen) {
                    applyUnsharpMask(imageData, width, height);
                }
            }

            function applyBoxBlur(imageData, width, height) {
                const data = imageData.data;
                const original = new Uint8ClampedArray(data);
                const kernel = [
                    1, 1, 1,
                    1, 1, 1,
                    1, 1, 1
                ];
                const kernelWeight = 9;
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let sum = 0;
                        let idxKernel = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4;
                                sum += original[idx] * kernel[idxKernel++];
                            }
                        }
                        const value = clamp(sum / kernelWeight);
                        const target = (y * width + x) * 4;
                        data[target] = data[target + 1] = data[target + 2] = value;
                    }
                }
            }

            // === å½±åƒè™•ç†åŠŸèƒ½ ===

            /**
             * æ‡‰ç”¨ééŠ³åŒ–é®ç½©æ¿¾é¡å¢å¼·å½±åƒæ¸…æ™°åº¦
             * @param {ImageData} imageData - è¦è™•ç†çš„å½±åƒè³‡æ–™
             * @param {number} width - å½±åƒå¯¬åº¦
             * @param {number} height - å½±åƒé«˜åº¦
             */
            function applyUnsharpMask(imageData, width, height) {
                const data = imageData.data;
                const original = new Uint8ClampedArray(data);
                const amount = 0.6; // éŠ³åŒ–å¼·åº¦

                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        const center = original[idx];
                        const north = original[idx - width * 4];
                        const south = original[idx + width * 4];
                        const east = original[idx + 4];
                        const west = original[idx - 4];

                        // æ‹‰æ™®æ‹‰æ–¯é‚Šç·£æª¢æ¸¬
                        const laplace = (4 * center) - north - south - east - west;
                        const value = clamp(center + amount * laplace);

                        // æ‡‰ç”¨åˆ° RGB ä¸‰å€‹é€šé“
                        data[idx] = data[idx + 1] = data[idx + 2] = value;
                    }
                }
            }

            /**
             * è¨ˆç®—æ„Ÿèˆˆè¶£å€åŸŸï¼ˆROIï¼‰çš„åº§æ¨™å’Œå¤§å°
             * @param {number} videoWidth - å½±ç‰‡å¯¬åº¦
             * @param {number} videoHeight - å½±ç‰‡é«˜åº¦
             * @returns {Object} ROI å€åŸŸè³‡è¨Š {sx, sy, sw, sh}
             */
            function computeRoi(videoWidth, videoHeight) {
                if (!state.roi.enabled) {
                    return { sx: 0, sy: 0, sw: videoWidth, sh: videoHeight };
                }

                const sw = videoWidth * state.roi.widthRatio;
                const sh = videoHeight * state.roi.heightRatio;
                const sx = (videoWidth - sw) / 2;
                const sy = (videoHeight - sh) / 2;

                return { sx, sy, sw, sh };
            }

            // === UI æ›´æ–°åŠŸèƒ½ ===

            /**
             * æ ¹æ“šåŒ¹é…çµæœæ›´æ–°çµæœå¡ç‰‡é¡¯ç¤º
             * @param {Object} match - åŒ¹é…çµæœç‰©ä»¶ {found, original, matchedCode}
             */
            function updateResultCardForMatch(match) {
                if (match.found) {
                    // é¡¯ç¤ºæˆåŠŸåŒ¹é…çµæœ
                    elements.resultCard.classList.remove('error');
                    elements.resultCard.classList.add('success');
                    elements.resultCard.innerHTML = `
                        <div class="success-title">
                            <span class="success-icon">ğŸ‰</span>
                            æ‰¾åˆ°ã€å¸ƒå¯æ˜Ÿçƒé¸æ›¸ã€
                        </div>
                        <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">
                            ${match.found.æ›¸å}
                        </div>
                        <div style="margin-bottom: 4px;">
                            <strong>ISBNï¼š</strong>${match.found.ISBN}
                        </div>
                        <div style="margin-bottom: 12px;">
                            <strong>é©åˆå°è±¡ï¼š</strong>${match.found.é©åˆå°è±¡ || 'æœªæ¨™ç¤º'}
                        </div>
                        <div style="font-size: 13px; color: var(--text-muted); padding-top: 8px; border-top: 1px solid rgba(16, 185, 129, 0.2);">
                            åŒ¹é…æ¢ç¢¼ï¼š${match.matchedCode}
                        </div>
                    `;
                } else {
                    // é¡¯ç¤ºæœªæ‰¾åˆ°çš„çµæœ
                    elements.resultCard.classList.remove('success');
                    elements.resultCard.classList.add('error');
                    elements.resultCard.innerHTML = `
                        <div class="error-title">
                            <span class="error-icon">âš ï¸</span>
                            æœªåœ¨å¸ƒå¯æ˜Ÿçƒæ›¸å–®ä¸­
                        </div>
                        <div style="font-size: 16px; margin: 12px 0; font-weight: 500;">
                            æ­¤æ¢ç¢¼ä¸åœ¨å¸ƒå¯æ˜Ÿçƒé¸æ›¸æ¸…å–®ä¸­
                        </div>
                        <div style="background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 12px; margin-top: 16px;">
                            <div style="font-size: 13px; margin-bottom: 4px; color: var(--text-muted);">
                                <strong>æƒææ¢ç¢¼ï¼š</strong>${match.original}
                            </div>
                            <div style="font-size: 13px; color: var(--text-muted);">
                                <strong>è™•ç†çµæœï¼š</strong>${match.matchedCode || 'ç„¡æ³•è­˜åˆ¥'}
                            </div>
                        </div>
                    `;
                }
            }

            // === æ¢ç¢¼è™•ç†åŠŸèƒ½ ===

            /**
             * é€²éšæ¢ç¢¼è™•ç†å™¨ï¼Œç”¢ç”Ÿå¤šç¨®å¯èƒ½çš„ISBNæ ¼å¼
             * @param {string} rawCode - åŸå§‹æ¢ç¢¼å­—ä¸²
             * @returns {Array<string>} è™•ç†å¾Œçš„å¯èƒ½ISBNæ ¼å¼é™£åˆ—ï¼ˆæœ€å°‘8ä½æ•¸ï¼‰
             */
            function advancedBarcodeProcessor(rawCode) {
                const cleaned = rawCode.replace(/\D/g, ''); // ç§»é™¤éæ•¸å­—å­—ç¬¦
                const results = new Set();

                if (!cleaned) return [];

                // åŠ å…¥æ¸…ç†å¾Œçš„åŸå§‹ç¢¼
                results.add(cleaned);

                // æ¨™æº–é•·åº¦è™•ç†
                if (cleaned.length === 18) results.add(cleaned.slice(0, 13));
                if (cleaned.length === 15) results.add(cleaned.slice(0, 10));
                if (cleaned.length > 13) results.add(cleaned.slice(0, 13));
                if (cleaned.length > 10) results.add(cleaned.slice(0, 10));

                // å»é™¤æœ€å¾Œä¸€ä½ï¼ˆå¯èƒ½æ˜¯æ ¡é©—ç¢¼ï¼‰
                if (cleaned.length > 8) {
                    results.add(cleaned.slice(0, cleaned.length - 1));
                }

                // æ»‘å‹•è¦–çª—è™•ç†ï¼ˆå°‹æ‰¾å¯èƒ½çš„ISBNï¼‰
                if (cleaned.length >= 10) {
                    for (let i = 0; i <= cleaned.length - 10; i++) {
                        const slice13 = cleaned.slice(i, i + 13);
                        const slice10 = cleaned.slice(i, i + 10);

                        if (slice13.length === 13) results.add(slice13);
                        if (slice10.length === 10) results.add(slice10);
                    }
                }

                // éæ¿¾çµæœï¼Œä¿ç•™è‡³å°‘8ä½æ•¸çš„å€™é¸ç¢¼
                return Array.from(results).filter(code => code.length >= 8);
            }

            /**
             * æ™ºæ…§æ›¸ç±åŒ¹é…åŠŸèƒ½ï¼Œä½¿ç”¨å¤šç¨®ç­–ç•¥å°‹æ‰¾æ›¸ç±
             * @param {string} rawCode - åŸå§‹æ¢ç¢¼å­—ä¸²
             * @returns {Object} åŒ¹é…çµæœ {found, original, matchedCode}
             */
            function intelligentBookMatch(rawCode) {
                const candidates = advancedBarcodeProcessor(rawCode);

                for (const candidate of candidates) {
                    const match = state.bookList.find(book => {
                        if (!book.ISBN) return false;

                        const normalized = book.ISBN.replace(/\D/g, '');

                        // å®Œå…¨åŒ¹é…
                        if (normalized === candidate) return true;

                        // ç›¸åŒé•·åº¦ä½†æœ€å¾Œä¸€ä½ä¸åŒï¼ˆæ ¡é©—ç¢¼å·®ç•°ï¼‰
                        if (normalized.length === candidate.length &&
                            normalized.substring(0, normalized.length - 1) === candidate.substring(0, candidate.length - 1)) {
                            return true;
                        }

                        // éƒ¨åˆ†åŒ…å«åŒ¹é…ï¼ˆå…è¨±å°å¹…é•·åº¦å·®ç•°ï¼‰
                        if (normalized.includes(candidate) || candidate.includes(normalized)) {
                            return Math.abs(normalized.length - candidate.length) <= 2;
                        }

                        return false;
                    });

                    if (match) {
                        return {
                            found: match,
                            matchedCode: candidate,
                            original: rawCode
                        };
                    }
                }

                return {
                    found: null,
                    matchedCode: candidates[0] || '',
                    original: rawCode
                };
            }

            // === æ¢ç¢¼åµæ¸¬åŠŸèƒ½ ===

            /**
             * ä½¿ç”¨åŸç”Ÿ BarcodeDetector API é€²è¡Œæ¢ç¢¼åµæ¸¬
             * @param {HTMLCanvasElement} canvas - è¦åµæ¸¬çš„ canvas å…ƒç´ 
             * @returns {Promise<Object|null>} åµæ¸¬çµæœæˆ– null
             */
            async function detectWithBarcodeDetector(canvas) {
                const detector = state.detectors.barcodeDetector;
                if (!detector || !state.detection.useBarcodeDetector) return null;

                try {
                    const detections = await detector.detect(canvas);
                    if (!detections || detections.length === 0) return null;

                    // å„ªå…ˆé¸æ“‡æœ‰æ•ˆé•·åº¦çš„æ¢ç¢¼ï¼Œå¦å‰‡é¸æ“‡ç¬¬ä¸€å€‹
                    const best = detections.find(det =>
                        det.rawValue && det.rawValue.replace(/\D/g, '').length >= 8
                    ) || detections[0];
                    if (!best || !best.rawValue) return null;

                    return {
                        text: best.rawValue,
                        engine: 'BarcodeDetector',
                        format: best.format || 'Unknown'
                    };
                } catch (error) {
                    log(`BarcodeDetector å¤±æ•—ï¼š${error.message}`);
                    return null;
                }
            }

            /**
             * ä½¿ç”¨ ZXing å‡½å¼åº«é€²è¡Œæ¢ç¢¼åµæ¸¬
             * @param {HTMLCanvasElement} canvas - è¦åµæ¸¬çš„ canvas å…ƒç´ 
             * @returns {Object|null} åµæ¸¬çµæœæˆ– null
             */
            function detectWithZxing(canvas) {
                const reader = state.detectors.multiFormatReader;
                if (!reader || !state.detection.useZxing || !checkZXingAvailability()) {
                    return null;
                }

                try {
                    const luminanceSource = new ZXingBrowser.HTMLCanvasElementLuminanceSource(canvas);
                    const binaryBitmap = new ZXing.BinaryBitmap(new ZXing.HybridBinarizer(luminanceSource));
                    const result = reader.decodeWithState(binaryBitmap);

                    // é‡ç½®è®€å–å™¨ç‹€æ…‹
                    if (reader.reset) {
                        reader.reset();
                    }

                    if (!result) return null;

                    return {
                        text: result.getText(),
                        engine: 'ZXing',
                        format: result.getBarcodeFormat ? result.getBarcodeFormat().toString() : 'Unknown'
                    };
                } catch (error) {
                    try {
                        if (reader.reset) {
                            reader.reset();
                        }
                    } catch (resetError) {
                        log(`ZXing reset å¤±æ•—ï¼š${resetError.message}`);
                    }

                    if (!(error instanceof ZXing.NotFoundException)) {
                        log(`ZXing å¤±æ•—ï¼š${error.message}`);
                    }
                    return null;
                }
            }

            async function detectFromCanvas(canvas, stageLabel) {
                let detection = await detectWithBarcodeDetector(canvas);
                if (detection) {
                    detection.stage = stageLabel;
                    return detection;
                }
                detection = detectWithZxing(canvas);
                if (detection) {
                    detection.stage = stageLabel;
                    return detection;
                }
                return null;
            }

            async function tryDetections() {
                const baseDetection = await detectFromCanvas(processingCanvas, 'åŸºç¤å½±åƒ');
                if (baseDetection) return baseDetection;

                if (state.detection.allowRotation) {
                    for (const angle of state.detection.rotationAngles) {
                        scratchCanvas.width = processingCanvas.width;
                        scratchCanvas.height = processingCanvas.height;
                        scratchCtx.save();
                        scratchCtx.clearRect(0, 0, scratchCanvas.width, scratchCanvas.height);
                        scratchCtx.translate(scratchCanvas.width / 2, scratchCanvas.height / 2);
                        scratchCtx.rotate(angle * Math.PI / 180);
                        scratchCtx.drawImage(processingCanvas, -processingCanvas.width / 2, -processingCanvas.height / 2);
                        scratchCtx.restore();
                        const rotatedDetection = await detectFromCanvas(scratchCanvas, `æ—‹è½‰ ${angle}Â°`);
                        if (rotatedDetection) return rotatedDetection;
                    }
                }

                if (state.detection.allowSlices) {
                    for (const slice of state.detection.slices) {
                        const sliceHeight = Math.round(processingCanvas.height * slice.heightRatio);
                        const sliceTop = Math.round(processingCanvas.height * slice.topRatio);
                        scratchCanvas.width = processingCanvas.width;
                        scratchCanvas.height = sliceHeight;
                        scratchCtx.clearRect(0, 0, scratchCanvas.width, scratchCanvas.height);
                        scratchCtx.drawImage(
                            processingCanvas,
                            0,
                            sliceTop,
                            processingCanvas.width,
                            sliceHeight,
                            0,
                            0,
                            scratchCanvas.width,
                            sliceHeight
                        );
                        const sliceDetection = await detectFromCanvas(scratchCanvas, `æƒæç·š-${slice.label}`);
                        if (sliceDetection) return sliceDetection;
                    }
                }

                return null;
            }

            function updateEngineBadge(text, success = false) {
                elements.engineBadge.textContent = text;
                elements.engineBadge.style.background = success ? 'rgba(0, 230, 118, 0.8)' : 'rgba(0, 0, 0, 0.6)';
                elements.engineBadge.style.borderColor = success ? 'rgba(0, 230, 118, 0.9)' : 'rgba(255, 255, 255, 0.2)';
                elements.engineBadge.style.color = success ? '#00281f' : '#e0f2f1';
            }

            // éš±è— popover çš„è¼”åŠ©å‡½æ•¸
            function hidePopover() {
                const popover = elements.successPopover;
                if (popover) {
                    popover.classList.remove('show', 'fade-out');
                    popover.style.display = 'none';
                }
            }

            function showSuccessPopover() {
                const resultCard = elements.resultCard;
                const popover = elements.successPopover;

                log('ğŸ‰ é–‹å§‹é¡¯ç¤ºæˆåŠŸ Popover');
                log(`ResultCard: ${resultCard ? 'âœ…æ‰¾åˆ°' : 'âŒæœªæ‰¾åˆ°'}`);
                log(`Popover: ${popover ? 'âœ…æ‰¾åˆ°' : 'âŒæœªæ‰¾åˆ°'}`);

                if (!resultCard || !popover) {
                    log('âš ï¸ Popover æˆ– ResultCard å…ƒç´ æœªæ‰¾åˆ°');
                    return;
                }

                // é‡ç½®æ‰€æœ‰æ¨£å¼å’Œé¡åˆ¥
                popover.classList.remove('show', 'fade-out');
                popover.style.display = 'block'; // é¡¯ç¤ºå…ƒç´ 
                popover.style.position = 'fixed';
                popover.style.zIndex = '9999';

                const rect = resultCard.getBoundingClientRect();
                log(`ResultCard ä½ç½®: left=${rect.left}, top=${rect.top}, width=${rect.width}, height=${rect.height}`);

                // è¨ˆç®—popoverä½ç½®ï¼ˆç›¸å°æ–¼è¦–çª—ï¼Œåœ¨ resultCard ä¸Šç·£ï¼‰
                const popoverLeft = rect.left + (rect.width / 2);
                const popoverTop = rect.top - 60; // åœ¨ resultCard ä¸Šæ–¹ 60px

                popover.style.left = `${popoverLeft}px`;
                popover.style.top = `${popoverTop}px`;
                popover.style.transform = 'translateX(-50%)';

                log(`Popover ä½ç½®è¨­å®š: left=${popoverLeft}px, top=${popoverTop}px`);
                log('ğŸ‰ Popover æ¨£å¼å·²è¨­å®šï¼Œæº–å‚™é¡¯ç¤ºå‹•ç•«');

                // å¼·åˆ¶ç€è¦½å™¨é‡ç¹ª
                popover.offsetHeight;

                // é¡¯ç¤ºå‹•ç•«
                requestAnimationFrame(() => {
                    log('âš¡ åŸ·è¡Œé¡¯ç¤ºå‹•ç•«ï¼šæ·»åŠ  show é¡åˆ¥');
                    popover.classList.add('show');

                    // æª¢æŸ¥æ˜¯å¦æˆåŠŸæ·»åŠ 
                    setTimeout(() => {
                        const hasShow = popover.classList.contains('show');
                        const computedStyle = window.getComputedStyle(popover);
                        log(`å‹•ç•«æª¢æŸ¥: showé¡åˆ¥=${hasShow}, opacity=${computedStyle.opacity}, transform=${computedStyle.transform}`);
                    }, 100);
                });

                // 1.5ç§’å¾Œæ·¡å‡º
                setTimeout(() => {
                    log('â° é–‹å§‹æ·¡å‡ºå‹•ç•«');
                    popover.classList.add('fade-out');
                    setTimeout(() => {
                        log('ğŸ”š æ¸…é™¤ Popover é¡åˆ¥å’Œæ¨£å¼');
                        popover.classList.remove('show', 'fade-out');
                        popover.style.position = 'absolute'; // æ¢å¾©åŸå§‹å®šä½
                        popover.style.display = 'none'; // éš±è—å…ƒç´ 
                    }, 300);
                }, 1500);
            }

            async function processFrame() {
                const video = elements.preview;
                if (!video.videoWidth || !video.videoHeight) return null;

                const now = performance.now();
                if (now - state.lastDetectionAt < state.detection.intervalMs) return null;
                state.lastDetectionAt = now;

                const roi = computeRoi(video.videoWidth, video.videoHeight);
                const targetWidth = Math.min(1280, Math.round(roi.sw));
                const targetHeight = Math.round(targetWidth * (roi.sh / roi.sw));
                processingCanvas.width = targetWidth;
                processingCanvas.height = targetHeight;
                processingCtx.drawImage(video, roi.sx, roi.sy, roi.sw, roi.sh, 0, 0, targetWidth, targetHeight);

                const imageData = processingCtx.getImageData(0, 0, targetWidth, targetHeight);
                applyImageProcessing(imageData, targetWidth, targetHeight);
                processingCtx.putImageData(imageData, 0, 0);

                const detection = await tryDetections();
                state.stats.frames++;
                updateStatsDisplay();
                return detection;
            }

            async function scanLoop() {
                while (state.running) {
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    if (!state.running) break;
                    if (state.detectionBusy) continue;
                    state.detectionBusy = true;
                    try {
                        const detection = await processFrame();
                        if (detection) {
                            handleDetection(detection);
                        }
                    } catch (error) {
                        log(`æƒæè¿´åœˆéŒ¯èª¤ï¼š${error.message}`);
                    } finally {
                        state.detectionBusy = false;
                    }
                }
            }

            function handleDetection(detection) {
                const cleaned = detection.text.replace(/\s+/g, '');
                if (cleaned.replace(/\D/g, '').length < 8) {
                    log(`ç•¥éçŸ­ç¢¼ï¼š${cleaned}`);
                    return;
                }

                if (wasRecentlySeen(cleaned)) {
                    return;
                }
                pushRecentCode(cleaned);

                state.stats.valid++;
                updateStatsDisplay();

                log(`âœ… ${detection.engine}(${detection.stage}) â†’ ${cleaned}`);
                elements.engineStatus.textContent = `${detection.engine} @ ${detection.stage}`;
                updateEngineBadge(`${detection.engine} å‘½ä¸­`, true);

                const match = intelligentBookMatch(cleaned);
                if (match.found) {
                    state.stats.success++;
                }
                updateStatsDisplay();
                updateResultCardForMatch(match);

                if (!match.found) {
                    setTimeout(() => {
                        updateEngineBadge('æŒçºŒæƒæä¸­â€¦');
                    }, 2000);
                    return;
                }

                log('ğŸ¯ æ‰¾åˆ°åŒ¹é…æ›¸ç±ï¼Œæº–å‚™é¡¯ç¤º popover');

                // é¡¯ç¤ºæˆåŠŸpopover
                showSuccessPopover();
                stopScanner(false);
            }

            async function startScanner() {
                if (state.running) return;

                try {
                    resetStats();
                    updateEngineBadge('å•Ÿå‹•æ”å½±æ©Ÿâ€¦');
                    elements.engineStatus.textContent = 'å•Ÿå‹•ä¸­';
                    log('æ­£åœ¨åˆå§‹åŒ–æ”å½±æ©Ÿâ€¦');

                    // å˜—è©¦ä½¿ç”¨ç°¡åŒ–çš„æ”å½±æ©Ÿè¨­å®š
                    try {
                        state.stream = await navigator.mediaDevices.getUserMedia({
                            video: {
                                facingMode: 'environment',
                                width: { ideal: 1920, min: 640 },
                                height: { ideal: 1080, min: 480 }
                            },
                            audio: false
                        });
                    } catch (error) {
                        // å¦‚æœå¤±æ•—ï¼Œå˜—è©¦æ›´åŸºæœ¬çš„è¨­å®š
                        log('å˜—è©¦åŸºæœ¬æ”å½±æ©Ÿè¨­å®š...');
                        state.stream = await navigator.mediaDevices.getUserMedia({
                            video: { facingMode: 'environment' },
                            audio: false
                        });
                    }

                    state.track = state.stream.getVideoTracks()[0];
                    elements.preview.srcObject = state.stream;
                    await elements.preview.play();

                    updateCameraStatusText();
                    updateRoiOverlay();

                    elements.startBtn.style.display = 'none';
                    elements.stopBtn.style.display = 'inline-flex';
                    elements.stopBtn.disabled = false;

                    const capabilities = state.track.getCapabilities ? state.track.getCapabilities() : {};
                    if (capabilities && capabilities.torch) {
                        elements.flashBtnHeader.disabled = false;
                        elements.flashBtnHeader.classList.remove('flash-on');
                        elements.flashIconHeader.textContent = 'ï¿½æ‰‹é›»ç­’';
                    } else {
                        elements.flashBtnHeader.disabled = true;
                        elements.flashBtnHeader.classList.remove('flash-on');
                        elements.flashIconHeader.textContent = 'ï¿½æ‰‹é›»ç­’';
                    }

                    state.flashOn = false;
                    state.running = true;
                    elements.resultCard.classList.remove('error', 'success');
                    elements.resultCard.textContent = 'æƒæä¸­ï¼Œè«‹å°‡æ¢ç¢¼ç½®æ–¼ç•«é¢ä¸­å¤®ä¸¦ä¿æŒç©©å®šã€‚';
                    elements.engineStatus.textContent = 'æƒæä¸­';
                    scanLoop();
                    log('ğŸ“½ï¸ æƒæè¿´åœˆå•Ÿå‹•');
                    updateEngineBadge('æƒæä¸­â€¦');
                } catch (error) {
                    log(`âŒ ç„¡æ³•å•Ÿå‹•æ”å½±æ©Ÿï¼š${error.message}`);
                    updateEngineBadge('å•Ÿå‹•å¤±æ•—');
                    elements.resultCard.classList.add('error');

                    let errorMessage = 'æ”å½±æ©Ÿå•Ÿå‹•å¤±æ•—';
                    if (error.name === 'NotAllowedError') {
                        errorMessage = 'âŒ æ”å½±æ©Ÿæ¬Šé™è¢«æ‹’çµ•ï¼Œè«‹å…è¨±æ­¤ç¶²ç«™ä½¿ç”¨æ”å½±æ©Ÿã€‚';
                    } else if (error.name === 'NotFoundError') {
                        errorMessage = 'âŒ æ‰¾ä¸åˆ°æ”å½±æ©Ÿè¨­å‚™ï¼Œè«‹ç¢ºèªæ”å½±æ©Ÿå·²é€£æ¥ã€‚';
                    } else if (error.name === 'NotReadableError') {
                        errorMessage = 'âŒ æ”å½±æ©Ÿæ­£è¢«å…¶ä»–æ‡‰ç”¨ç¨‹å¼ä½¿ç”¨ä¸­ã€‚';
                    } else {
                        errorMessage = `âŒ æ”å½±æ©Ÿå•Ÿå‹•å¤±æ•—ï¼š${error.message}`;
                    }

                    elements.resultCard.textContent = errorMessage;
                    stopScanner(true);
                }
            }

            function stopScanner(resetStatsToo = true) {
                state.running = false;
                state.detectionBusy = false;
                if (state.track) {
                    try { state.track.stop(); } catch (error) { log(`åœæ­¢ track å¤±æ•—ï¼š${error.message}`); }
                    state.track = null;
                }
                if (state.stream) {
                    state.stream.getTracks().forEach(track => track.stop());
                    state.stream = null;
                }
                elements.preview.srcObject = null;
                updateEngineBadge('å·²åœæ­¢');
                elements.engineStatus.textContent = 'å·²åœæ­¢';
                elements.startBtn.style.display = 'inline-flex';
                elements.stopBtn.style.display = 'none';
                elements.flashBtnHeader.disabled = true;
                elements.flashBtnHeader.classList.remove('flash-on');
                elements.flashIconHeader.textContent = 'ï¿½æ‰‹é›»ç­’';
                state.flashOn = false;
                updateCameraStatusText();
                if (resetStatsToo) {
                    resetStats();
                }
            }

            async function toggleFlash() {
                if (!state.track) return;
                const capabilities = state.track.getCapabilities ? state.track.getCapabilities() : {};
                if (!capabilities || !capabilities.torch) {
                    elements.flashIconHeader.textContent = 'ä¸æ”¯æ´æ‰‹é›»ç­’';
                    elements.flashBtnHeader.disabled = true;
                    return;
                }
                state.flashOn = !state.flashOn;
                try {
                    await state.track.applyConstraints({ advanced: [{ torch: state.flashOn }] });
                    elements.flashIconHeader.textContent = state.flashOn ? 'ï¿½é—œé–‰æ‰‹é›»ç­’' : 'ï¿½æ‰‹é›»ç­’';
                    elements.flashBtnHeader.classList.toggle('flash-on', state.flashOn);
                } catch (error) {
                    log(`æ‰‹é›»ç­’åˆ‡æ›å¤±æ•—ï¼š${error.message}`);
                }
            }

            function updateCameraStatusText() {
                if (!state.track) {
                    elements.cameraStatus.textContent = 'å°šæœªå•Ÿå‹•';
                    return;
                }
                const settings = state.track.getSettings();
                elements.cameraStatus.textContent = `${settings.width || '?'}Ã—${settings.height || '?'} @ ${Math.round(settings.frameRate || 0)}fps`;
            }

            function bindEvents() {
                elements.startBtn.addEventListener('click', startScanner);
                elements.stopBtn.addEventListener('click', () => stopScanner(false));
                elements.flashBtnHeader.addEventListener('click', toggleFlash);

                // æ¸¬è©¦æŒ‰éˆ•äº‹ä»¶
                const testSuccessBtn = document.getElementById('testSuccessBtn');
                if (testSuccessBtn) {
                    testSuccessBtn.addEventListener('click', () => {
                        log('ğŸ“š æ‰‹å‹•æ¸¬è©¦å¸ƒå¯æ˜Ÿçƒé¸æ›¸æˆåŠŸæƒæ');

                        // æ¨¡æ“¬ä¸€å€‹æˆåŠŸçš„å¸ƒå¯æ˜Ÿçƒæ›¸ç±æƒæçµæœ
                        const mockMatch = {
                            found: {
                                æ›¸å: "å°ç‹å­",
                                ISBN: "9789571234567",
                                é©åˆå°è±¡: "6-12æ­²"
                            },
                            matchedCode: "9789571234567",
                            original: "9789571234567"
                        };

                        // æ›´æ–°çµ±è¨ˆ
                        state.stats.valid++;
                        state.stats.success++;
                        updateStatsDisplay();

                        // é¡¯ç¤ºæˆåŠŸçµæœï¼ˆåŒ…å«å‹•ç•«ï¼‰
                        updateResultCardForMatch(mockMatch);

                        // é¡¯ç¤ºæˆåŠŸå½ˆçª—
                        showSuccessPopover();

                        // æ›´æ–°å¼•æ“ç‹€æ…‹
                        elements.engineStatus.textContent = 'æ¸¬è©¦å¼•æ“ @ æ¨¡æ“¬æƒæ';
                        updateEngineBadge('æ¸¬è©¦æˆåŠŸ', true);

                        // 2ç§’å¾Œé‡ç½®å¼•æ“ç‹€æ…‹
                        setTimeout(() => {
                            updateEngineBadge('å¾…å‘½ä¸­...');
                        }, 2000);
                    });
                }

                window.addEventListener('resize', updateRoiOverlay);
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        stopScanner(false);
                    }
                });

                // æ»¾å‹•æ™‚éš±è— popover
                window.addEventListener('scroll', hidePopover);
                // è§¸æ§æ»‘å‹•æ™‚ä¹Ÿéš±è— popover
                window.addEventListener('touchmove', hidePopover);
            }

            // ç­‰å¾… DOM å®Œå…¨è¼‰å…¥
            document.addEventListener('DOMContentLoaded', () => {
                initDetectors();
                bindEvents();
                loadBookList();

                // æª¢æŸ¥åŸºæœ¬åŠŸèƒ½
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    elements.resultCard.classList.add('error');
                    elements.resultCard.textContent = 'âŒ æ­¤ç€è¦½å™¨ä¸æ”¯æ´æ”å½±æ©ŸåŠŸèƒ½ï¼Œè«‹ä½¿ç”¨è¼ƒæ–°çš„ç€è¦½å™¨ã€‚';
                    elements.startBtn.disabled = true;
                }
            });
        })();
    </script>

    <!-- é é¢åº•éƒ¨è³‡è¨Š -->
    <footer class="page-footer">
        <div class="footer-content">
            <!-- ä½¿ç”¨çµ±è¨ˆå€å¡Š -->
            <div class="stats-section">
                <h3>ğŸ“Š ä½¿ç”¨çµ±è¨ˆ</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-number" id="visitCount">è¼‰å…¥ä¸­...</span>
                        <span class="stat-label">ç´¯è¨ˆè¨ªå•</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" id="scanCount">0</span>
                        <span class="stat-label">æœ¬æ¬¡æƒæ</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" id="bookCount">è¼‰å…¥ä¸­...</span>
                        <span class="stat-label">æ›¸ç±è³‡æ–™åº«</span>
                    </div>
                </div>
            </div>
            <!-- è¯ç¹«ä½œè€…å€å¡Š -->
            <div class="contact-section">
                <div class="contact-links">
                    <span class="contact-item">ğŸ’¡ ç•™è¨€å›é¥‹</span>
                    <a href="mailto:colinjen88@gmail.com" class="contact-item">â­ å¯«ä¿¡çµ¦ä½œè€…</a>
                </div>
            </div>

            <!-- ç‰ˆæ¬Šè³‡è¨Š -->
            <div class="copyright-section">
                <div class="app-info">
                    <span class="app-title">ğŸ“˜ æŸ¥è©¢å¸ƒå¯æ˜Ÿçƒæ¢ç¢¼å°å·¥å…·</span>
                    <span class="app-version">v1.0</span>
                </div>
                <div class="copyright-text">
                    <span>Â© 2025 æ•™è‚²ç”¨é€” | Made with â¤ï¸ in Taiwan</span>
                    <span class="update-time">æœ€å¾Œæ›´æ–°ï¼š2025å¹´10æœˆ9æ—¥</span>
                </div>
            </div>
        </div>
    </footer>

    <script>
        // === çµ±è¨ˆåŠŸèƒ½æ¨¡çµ„ ===
        (function () {
            // å¸¸æ•¸å®šç¾©
            const VISIT_COOLDOWN_MS = 15 * 60 * 1000; // 15åˆ†é˜å†·å»æ™‚é–“
            const STORAGE_KEYS = {
                visitCount: 'bookScannerVisitCount',
                lastVisit: 'bookScannerLastVisit'
            };

            // å…§éƒ¨ç‹€æ…‹
            let scanCount = 0;

            /**
             * æ›´æ–°æƒææ¬¡æ•¸
             */
            function updateScanCount() {
                scanCount++;
                const element = document.getElementById('scanCount');
                if (element) {
                    element.textContent = scanCount;
                }
            }

            /**
             * ç²å–ä¸¦é¡¯ç¤ºè¨ªå•æ¬¡æ•¸ï¼ˆé¿å…15åˆ†é˜å…§é‡è¤‡ç´¯è¨ˆï¼‰
             */
            function updateVisitCount() {
                const now = Date.now();
                const lastVisitTime = localStorage.getItem(STORAGE_KEYS.lastVisit);
                const visitCount = parseInt(localStorage.getItem(STORAGE_KEYS.visitCount) || 0);

                // æª¢æŸ¥æ˜¯å¦è·é›¢ä¸Šæ¬¡è¨ªå•å·²è¶…éå†·å»æ™‚é–“
                if (!lastVisitTime || (now - parseInt(lastVisitTime)) > VISIT_COOLDOWN_MS) {
                    const newVisitCount = visitCount + 1;
                    localStorage.setItem(STORAGE_KEYS.visitCount, newVisitCount);
                    localStorage.setItem(STORAGE_KEYS.lastVisit, now.toString());

                    const element = document.getElementById('visitCount');
                    if (element) {
                        element.textContent = newVisitCount.toLocaleString();
                    }
                } else {
                    // å†·å»æ™‚é–“å…§çš„è¨ªå•ï¼Œä¸ç´¯åŠ ä½†é¡¯ç¤ºç¾æœ‰è¨ˆæ•¸
                    const element = document.getElementById('visitCount');
                    if (element) {
                        element.textContent = visitCount.toLocaleString();
                    }
                }
            }

            // æ›´æ–°æ›¸ç±è³‡æ–™åº«æ•¸é‡
            function updateBookCount() {
                // ç›£è½æ›¸ç±è¼‰å…¥å®Œæˆäº‹ä»¶
                window.addEventListener('booksLoaded', function (event) {
                    const bookCount = event.detail.count;
                    document.getElementById('bookCount').textContent = bookCount.toLocaleString();
                });

                // ç›£è½æ›¸ç±è¼‰å…¥å¤±æ•—äº‹ä»¶
                window.addEventListener('booksLoadError', function () {
                    document.getElementById('bookCount').textContent = 'è¼‰å…¥å¤±æ•—';
                });

                // å‚™ç”¨æª¢æŸ¥æ©Ÿåˆ¶ï¼ˆä»¥é˜²äº‹ä»¶ç³»çµ±å¤±æ•—ï¼‰
                const checkBookList = () => {
                    if (window.state && window.state.bookList && window.state.bookList.length > 0) {
                        document.getElementById('bookCount').textContent = window.state.bookList.length.toLocaleString();
                        return true;
                    }
                    return false;
                };

                // å»¶é²æª¢æŸ¥ï¼Œç¢ºä¿èƒ½æ•æ‰åˆ°æ›¸ç±æ•¸é‡
                setTimeout(() => {
                    if (!checkBookList()) {
                        // å¦‚æœé‚„æ˜¯æ²’æœ‰æ•¸æ“šï¼Œå˜—è©¦ç›´æ¥è¼‰å…¥
                        fetch('books_list.json')
                            .then(response => response.json())
                            .then(bookList => {
                                document.getElementById('bookCount').textContent = bookList.length.toLocaleString();
                            })
                            .catch(error => {
                                console.log('è¼‰å…¥æ›¸ç±æ•¸é‡å¤±æ•—:', error);
                                document.getElementById('bookCount').textContent = 'è¼‰å…¥å¤±æ•—';
                            });
                    }
                }, 2000);
            }

            // ç›£è½æƒææˆåŠŸäº‹ä»¶
            document.addEventListener('DOMContentLoaded', function () {
                updateVisitCount();
                updateBookCount();

                // ç›£è½æƒææˆåŠŸï¼ˆç•¶çµæœå¡ç‰‡é¡¯ç¤ºæˆåŠŸæ™‚ï¼‰
                const observer = new MutationObserver(function (mutations) {
                    mutations.forEach(function (mutation) {
                        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                            const target = mutation.target;
                            if (target.classList.contains('success')) {
                                updateScanCount();
                            }
                        }
                    });
                });

                const resultCard = document.getElementById('resultCard');
                if (resultCard) {
                    observer.observe(resultCard, { attributes: true });
                }
            });
        })();
    </script>
</body>

</html>